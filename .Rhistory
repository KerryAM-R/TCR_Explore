})
observe({
updateSelectInput(
session,
"V.gene.2",
choices=names(input.data_CSV1()),
selected = "BJ")
})
observe({
updateSelectInput(
session,
"CDR3.2",
choices=names(input.data_CSV1()),
selected = "CDR3b.Sequence")
})
observe({
updateSelectInput(
session,
"string.data",
choices=names(input.data_CSV1()),
selected = c("Indiv","TRBV","CDR3b.Sequence","TRBJ","TRAV","CDR3a.Sequence", "TRAJ","AJ", "BJ","AJBJ"))
})
index.cleaning1 <- reactive({
df <- input.data_CSV1();
validate(
need(nrow(df)>0,
error_message_val2)
)
df <- as.data.frame(df)
head(df)
df$cloneCount <- 1
df2 <- df[,c("cloneCount",input$string.data)]
df2
df3 <- as.data.frame(ddply(df2,input$string.data,numcolwise(sum)))
df3
df1 <- subset(df3,df3$cloneCount>input$numeric.cloneCount)
df1$clonal <- "yes"
colnames(df1)[which(names(df1) == "cloneCount")] <- "# of clones"
a <- df1[names(df1) %in% input$V.gene.1]
names(a) <- "V1"
b <- df1[names(df1) %in% input$CDR3.1]
names(b) <- "V1"
group.CDR <- df1[names(df1) %in% input$group.col.dot]
names(group.CDR) <- "V1"
d <- df1[names(df1) %in% input$V.gene.2]
names(d) <- "V1"
e  <- df1[names(df1) %in% input$CDR3.2]
names(e) <- "V1"
df1$gene.CDR3.1 <- paste(a$V1,b$V1,group.CDR$V1,sep="_")
df1$gene.CDR3.2 <- paste(d$V1,e$V1,group.CDR$V1,sep = "_")
df1$gene.CDR3.both <- paste(a$V1,b$V1,d$V1,e$V1,group.CDR$V1,sep = "_")
df1
a2 <- merge(df,df1,by=input$string.data,all=T)
#a[is.na(a)] <- 'unique'
a2 <- as.data.frame(a2)
a2[a2< -10000] <- 0.0001
a2[a2< -9000] <- 0.0002
a2[a2< -8000] <- 0.0003
a2[a2< -7000] <- 0.0004
a2[a2< -6000] <- 0.0005
a2[a2< -5000] <- 0.0006
a2[a2< -4000] <- 0.0007
a2[a2< -3000] <- 0.0008
a2[a2< -2000] <- 0.0009
a2[a2< -1000] <- 0.0010
a2[a2< -900] <- 0.0020
a2[a2< -800] <- 0.0030
a2[a2< -700] <- 0.0040
a2[a2< -600] <- 0.0050
a2[a2< -500] <- 0.0060
a2[a2< -400] <- 0.0070
a2[a2< -300] <- 0.0080
a2[a2< -200] <- 0.0090
a2[a2< -190] <- 0.0091
a2[a2< -180] <- 0.0092
a2[a2< -170] <- 0.0093
a2[a2< -160] <- 0.0094
a2[a2< -150] <- 0.0095
a2[a2< -140] <- 0.0096
a2[a2< -130] <- 0.0097
a2[a2< -120] <- 0.0098
a2[a2< -110] <- 0.0099
a2[a2< -100] <- 0.0100
a2[a2< -90] <- 0.020
a2[a2< -80] <- 0.030
a2[a2< -70] <- 0.040
a2[a2< -60] <- 0.050
a2[a2< -50] <- 0.060
a2[a2< -40] <- 0.070
a2[a2< -30] <- 0.080
a2[a2< -20] <- 0.090
a2[a2< -10] <- 0.1
a2[a2< -9] <- 0.2
a2[a2< -8] <- 0.3
a2[a2< -7] <- 0.4
a2[a2< -6] <- 0.5
a2[a2< -5] <- 0.6
a2[a2< -4] <- 0.7
a2[a2< -3] <- 0.8
a2[a2< -2] <- 0.9
a2[a2< 0] <- 1
a2
})
output$downloadTABLE_cleaning <- downloadHandler(
filename = function(){
paste(input$name.colour,"colouring column",gsub("-", ".", Sys.Date()),".csv", sep = "")
},
content = function(file){
write.csv(index.cleaning1(),file, row.names = FALSE)
})
output$table.index.1 <- DT::renderDataTable(escape = FALSE,options = list(lengthMenu = c(2,5,10,20,50,100), pageLength = 10, scrollX = TRUE),{
df <- index.cleaning1()
df
})
# creating the dot plot ----
input.data_CSV2 <-  reactive({switch(input$dataset_index.2,"test-csv"=test.data_csv2(),"own_csv_file" = own.data_CSV2())})
test.data_csv2<- reactive({
dataframe = read.csv(system.file("extdata","test-data/Index/colouring column2021.11.19.csv",package = "TCR.Explore"),header = T)
})
own.data_CSV2 <- reactive({
inFile_CSV2 <- input$file_FACS.csv2
if (is.null(inFile_CSV2)) return(NULL)
else {
dataframe <- read.csv(inFile_CSV2$datapath, header=T)}
})
observe({
dat <- input.data_CSV2()
validate(
need(nrow(dat)>0,
"Upload file for dotplot")
)
names(dat) <- gsub("\\.", " ", names(dat))
updateSelectInput(
session,
"x.axis2",
choices=names(dat),
selected = "tetramer no 2 PE")
})
observe({
dat <- input.data_CSV2()
validate(
need(nrow(dat)>0,
"Upload file for dotplot")
)
names(dat) <- gsub("\\.", " ", names(dat))
updateSelectInput(
session,
"y.axis2",
choices=names(dat),
selected = "tetramer no 1 APC")
})
observe({
dat <- input.data_CSV2()
validate(
need(nrow(dat)>0,
"Upload file for dotplot")
)
names(dat) <- gsub("\\.", " ", names(dat))
updateSelectInput(
session,
"group_complex_dot",
choices=names(dat),
selected = "AJBJ")
})
cols.FACS.index <- reactive({
dat <- input.data_CSV2()
validate(
need(nrow(dat)>0,
"Upload file for dotplot")
)
names(dat) <- gsub("\\.", " ", names(dat))
dat <- as.data.frame(dat)
dat[is.na(dat)] <- "not_clonal"
num <- unique(dat[names(dat) %in% input$group_complex_dot])
col.gg <- gg_fill_hue(dim(num)[1])
unique.col <- as.data.frame(unique(dat[grep(input$group_complex_dot,names(dat))]))
if (input$FACS.index_colour.choise == "default") {
lapply(1:dim(num)[1], function(i) {
colourInput(paste("col.FACS.index", i, sep="_"), paste(num[i,]), col.gg[i])
})
}
else if (input$FACS.index_colour.choise == "random") {
palette1 <- distinctColorPalette(dim(unique.col)[1])
lapply(1:dim(num)[1], function(i) {
colourInput(paste("col.FACS.index", i, sep="_"), paste(num[i,]), palette1[i])
})
}
else {
lapply(1:dim(num)[1], function(i) {
colourInput(paste("col.FACS.index", i, sep="_"), paste(num[i,]), "grey")
})
}
})
shape.FACS.index <- reactive({
dat <- input.data_CSV2()
validate(
need(nrow(dat)>0,
"Upload file for dotplot")
)
names(dat) <- gsub("\\.", " ", names(dat))
validate(
need(nrow(dat)>0,
"Upload file")
)
dat <- as.data.frame(dat)
dat[is.na(dat)] <- "not_clonal"
num <- unique(dat[names(dat) %in% input$group_complex_dot])
lapply(1:dim(num)[1], function(i) {
numericInput(paste("shape.FACS.index", i, sep="_"), paste(num[i,]), 19)
})
})
size.FACS.index <- reactive({
dat <- input.data_CSV2()
validate(
need(nrow(dat)>0,
"Upload file for dotplot")
)
names(dat) <- gsub("\\.", " ", names(dat))
validate(
need(nrow(dat)>0,
"Upload file")
)
dat <- as.data.frame(dat)
dat[is.na(dat)] <- "not_clonal"
num <- unique(dat[names(dat) %in% input$group_complex_dot])
lapply(1:dim(num)[1], function(i) {
numericInput(paste("size.FACS.index", i, sep="_"), paste(num[i,]), 3)
})
})
alpha.FACS.index <- reactive({
dat <- input.data_CSV2();
validate(
need(nrow(dat)>0,
"Upload file for dotplot")
)
dat <- as.data.frame(dat)
dat[is.na(dat)] <- "not_clonal"
num <- unique(dat[names(dat) %in% input$group_complex_dot])
lapply(1:dim(num)[1], function(i) {
numericInput(paste("alpha.FACS.index", i, sep="_"), paste(num[i,]), 1)
})
})
output$myPanel.FACS.index.shape <- renderUI({shape.FACS.index()})
output$myPanel.FACS.index <- renderUI({cols.FACS.index()})
output$myPanel.FACS.index.size <- renderUI({size.FACS.index()})
colors.FACS.index <- reactive({
dat <- input.data_CSV2()
validate(
need(nrow(dat)>0,
"Upload file for dotplot")
)
names(dat) <- gsub("\\.", " ", names(dat))
validate(
need(nrow(dat)>0,
"Upload file")
)
dat <- as.data.frame(dat)
dat[is.na(dat)] <- "not_clonal"
num <- unique(dat[names(dat) %in% input$group_complex_dot])
lapply(1:dim(num)[1], function(i) {
input[[paste("col.FACS.index", i, sep="_")]]
})
})
shape.FACS.index2 <- reactive({
dat <- input.data_CSV2()
validate(
need(nrow(dat)>0,
"Upload file for dotplot")
)
names(dat) <- gsub("\\.", " ", names(dat))
validate(
need(nrow(dat)>0,
"Upload file")
)
dat <- as.data.frame(dat)
dat[is.na(dat)] <- "not_clonal"
num <- unique(dat[names(dat) %in% input$group_complex_dot])
lapply(1:dim(num)[1], function(i) {
input[[paste("shape.FACS.index", i, sep="_")]]
})
})
size.FACS.index2 <- reactive({
dat <- input.data_CSV2()
validate(
need(nrow(dat)>0,
"Upload file for dotplot")
)
names(dat) <- gsub("\\.", " ", names(dat))
validate(
need(nrow(dat)>0,
"Upload file")
)
dat <- as.data.frame(dat)
dat[is.na(dat)] <- "not_clonal"
num <- unique(dat[names(dat) %in% input$group_complex_dot])
lapply(1:dim(num)[1], function(i) {
input[[paste("size.FACS.index", i, sep="_")]]
})
})
dot_plot.complex <- reactive({
index <- input.data_CSV2();
validate(
need(nrow(index)>0,
"Upload file")
)
names(index) <- gsub("\\.", " ", names(index))
index <- as.data.frame(index)
y_lable1 <- bquote(.(input$y.axis2))
x_lable1 <-  bquote(.(input$x.axis2))
index[is.na(index)] <- "not_clonal"
selected.col <- index[names(index) %in% input$group_complex_dot]
names(selected.col) <- "V1"
index[names(index) %in% input$group_complex_dot] <- factor(selected.col$V1, levels = unique(selected.col$V1),labels = unique(selected.col$V1))
palette.complex <- unlist(colors.FACS.index())
shape.ggplot <- unlist(shape.FACS.index2())
size.ggplot <- unlist(size.FACS.index2())
vals15$complex_dot <- ggplot(index, aes(x=get(input$x.axis2), y=get(input$y.axis2),
colour = get(input$group_complex_dot),
shape = get(input$group_complex_dot),
size  = get(input$group_complex_dot),
)
)+
geom_point() +
scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
limits = c(input$min.x,10^input$max.x),
labels = trans_format("log10", math_format(10^.x))) +
scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
limits = c(input$min.y,10^input$max.y),
labels = trans_format("log10", math_format(10^.x))) +
theme_bw() +
scale_color_manual(values=palette.complex) +
scale_shape_manual(values=shape.ggplot)+
scale_size_manual(values=size.ggplot)+
geom_hline(yintercept = input$yintercept,colour=input$intercept.col,linetype=input$int.type)+
geom_vline(xintercept = input$xintercept,colour=input$intercept.col, linetype=input$int.type)+
annotation_logticks()  +
theme(text=element_text(size=20,family=input$font_type2),
axis.text.x = element_text(colour="black",size=input$axis.numeric.size,angle=0,hjust=.5,vjust=.5,face="plain",family=input$font_type2),
axis.text.y = element_text(colour="black",size=input$axis.numeric.size,angle=0,hjust=1,vjust=0,face="plain",family=input$font_type2),
axis.title.x=element_text(colour="black",size=input$axis.title.size,angle=0,hjust=.5,vjust=.5,face="plain",family=input$font_type2),
axis.title.y = element_text(colour="black",size=input$axis.title.size,angle=90,hjust=.5,vjust=.5,face="plain",family=input$font_type2),
legend.title  =element_blank(),
legend.position = input$legend.dot,
legend.text = element_text(colour="black",size=input$legend.size.cd,hjust=.5,vjust=.5,face="plain",family=input$font_type2)) +
scale_alpha(guide = 'none') +
guides(size=FALSE, col = guide_legend(ncol=input$legend.column,override.aes = list(size=input$leg.dot.size)))+
labs(x=x_lable1,
y=y_lable1)
vals15$complex_dot
})
dot_plot.complex1 <- function () {
if (input$density_dotplot =="no" & input$grid.lines.dot =='no') {
dot_plot.complex() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
}
else if (input$density_dotplot =="no" & input$grid.lines.dot =='yes') {
dot_plot.complex()
}
else if (input$density_dotplot =="yes" & input$grid.lines.dot =='no') {
dot_plot <- dot_plot.complex() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
ggExtra::ggMarginal(dot_plot,groupColour = TRUE, groupFill = TRUE)
}
else {
ggExtra::ggMarginal(dot_plot.complex(),groupColour = TRUE, groupFill = TRUE)
}
}
output$dot_plot.complex2 <- renderPlot({
withProgress(message = 'Figure is being generated...',
detail = '', value = 0, {
test_fun()
})
dot_plot.complex1()
})
output$downloadPlot_complex.dotplot <- downloadHandler(
filename = function() {
x <- gsub(":", ".", Sys.time())
paste(input$name.colour3,"complex.dotplot_",gsub("/", "-", x), ".pdf", sep = "")
}, content = function(file) {
pdf(file, width=input$width_complex.dotplot,height=input$height_complex.dotplot, onefile = FALSE) # open the pdf device
print(dot_plot.complex1())
dev.off()},
contentType = "application/pdf" )
output$downloadPlotPNG_complex.dotplot <- downloadHandler(
filename = function() {
x <- gsub(":", ".", Sys.time())
paste(input$name.colour3,"complex.dotplot_", gsub("/", "-", x), ".png", sep = "")
},
content = function(file) {
png(file, width = input$width_png_complex.dotplot, height = input$height_png_complex.dotplot, res = input$resolution_PNG_complex.dotplot)
print(dot_plot.complex1())
dev.off()}, contentType = "application/png" # MIME type of the image
)
# upset diagram -----
vals23 <- reactiveValues(upset.plot=NULL)
observe({
updateSelectInput(
session,
"upset.select",
choices=names(input.data2()),
selected = "AJBJ")
})
observe({
updateSelectInput(
session,
"upset.group.select",
choices=names(select_group()),
selected = "group")
})
observe({
updateSelectInput(
session,
"order.of.group",
choices=select_group(),
selected = c("CD8","IFN"))
})
upset.parameters <- function () {
df <- input.data2();
validate(
need(nrow(df)>0,
error_message_val1)
)
df <- as.data.frame(df)
head(df)
unique.df <- unique(df[c(input$upset.select,input$upset.group.select)])
names(unique.df) <- c("chain","group")
unique.df$cloneCount <- 1
mat <- acast(unique.df, chain~group, value.var="cloneCount")
mat[is.na(mat)] <- 0
mat <- as.data.frame(mat)
# a <- as.data.frame(unique(names(mat)))
#   a$V1 <- distinctColorPalette(dim(a)[1])
df.x <- make_comb_mat(mat)
ht = draw(UpSet(df.x,
row_names_gp =  gpar(fontfamily = 'serif', fontsize = input$upset.text.size),
column_names_gp = gpar(fontfamily = 'serif'),
top_annotation = upset_top_annotation(df.x,
annotation_name_gp = gpar(fontfamily = 'serif')
),
right_annotation = upset_right_annotation(df.x,
annotation_name_gp = gpar(fontfamily = 'serif')),
set_order  = c(input$order.of.group)
), padding = unit(c(20, 20, 20, 20), "mm"))
od = column_order(ht)
cs = comb_size(df.x)
decorate_annotation("intersection_size", {
grid.text(cs[od], x = seq_along(cs), y = unit(cs[od], "native") + unit(2, "pt"),
default.units = "native", just = "bottom", gp = gpar(fontsize = input$upset.font.size, fontfamily = 'serif')
) })
}
output$UpSet.plot <- renderPlot({
withProgress(message = 'Figure is being generated...',
detail = '', value = 0, {
test_fun()
})
upset.parameters()
})
upset.datatable1 <- reactive({
df <- input.data2();
validate(
need(nrow(df)>0,
error_message_val1)
)
df <- as.data.frame(df)
head(df)
unique.df <- unique(df[c(input$upset.select,input$upset.group.select)])
names(unique.df) <- c("chain","group")
unique.df$cloneCount <- 1
mat <- acast(unique.df, chain~group, value.var="cloneCount")
mat[is.na(mat)] <- 0
mat <- as.data.frame(mat)
mat
})
output$upset.datatable <- DT::renderDataTable( {
datatable(upset.datatable1(), extensions = "Buttons", options = list(searching = TRUE,
ordering = TRUE,
buttons = c('copy','csv', 'excel'),
dom = 'Bfrtip',
pageLength=2,
lengthMenu=c(2,5,10,20,50,100),
scrollX = TRUE
))
}, server = FALSE)
output$downloadPlot_upset <- downloadHandler(
filename = function() {
x <- gsub(":", ".", Sys.time())
paste("upset_",gsub("/", "-", x), ".pdf", sep = "")
}, content = function(file) {
pdf(file, width=input$width_upset,height=input$height_upset, onefile = FALSE) # open the pdf device
print(upset.parameters())
dev.off()}, contentType = "application/pdf" )
output$downloadPlotPNG_upset <- downloadHandler(
filename = function() {
x <- gsub(":", ".", Sys.time())
paste("upset_", gsub("/", "-", x), ".png", sep = "")
},
content = function(file) {
png(file, width = input$width_png_upset, height = input$height_png_upset, res = input$resolution_PNG_upset)
print(upset.parameters())
dev.off()}, contentType = "application/png" # MIME type of the image
)
}
shinyApp(ui, server)
}
runApp('R')
runApp('R')
system.file("extdata","Tree.md",package = "TCR.Explore")
runApp('TCR_Explore_v1.0.R')
runApp('R')
system.file("www","Images/treemap.png",package = "TCR.Explore")
runApp('R')
runApp('TCR_Explore_v1.0.R')
runApp('TCR_Explore_v1.0.R')
runApp('TCR_Explore_v1.0.R')
