)
dat <- as.data.frame(dat)
dat[is.na(dat)] <- "not_clonal"
num <- unique(dat[names(dat) %in% input$group_complex_dot])
lapply(1:dim(num)[1], function(i) {
input[[paste("shape.FACS.index", i, sep="_")]]
})
})
size.FACS.index2 <- reactive({
dat <- input.data_CSV2()
validate(
need(nrow(dat)>0,
"Upload file for dotplot")
)
names(dat) <- gsub("\\.", " ", names(dat))
validate(
need(nrow(dat)>0,
"Upload file")
)
dat <- as.data.frame(dat)
dat[is.na(dat)] <- "not_clonal"
num <- unique(dat[names(dat) %in% input$group_complex_dot])
lapply(1:dim(num)[1], function(i) {
input[[paste("size.FACS.index", i, sep="_")]]
})
})
dot_plot.complex <- reactive({
set.seed(123)
index <- input.data_CSV2();
validate(
need(nrow(index)>0,
"Upload file")
)
names(index) <- gsub("\\.", " ", names(index))
index <- as.data.frame(index)
y_lable1 <- bquote(.(input$y.axis2))
x_lable1 <-  bquote(.(input$x.axis2))
index[is.na(index)] <- "not_clonal"
selected.col <- index[names(index) %in% input$group_complex_dot]
names(selected.col) <- "V1"
index[names(index) %in% input$group_complex_dot] <- factor(selected.col$V1, levels = unique(selected.col$V1),labels = unique(selected.col$V1))
palette.complex <- unlist(colors.FACS.index())
shape.ggplot <- unlist(shape.FACS.index2())
size.ggplot <- unlist(size.FACS.index2())
names_unique <- as.data.frame(unique(selected.col))
names_unique_size <- cbind(names_unique,as.data.frame(size.ggplot))
names(names_unique_size)[1] <- input$group_complex_dot
index2 <- merge(index,names_unique_size,by=input$group_complex_dot)
vals15$complex_dot <- ggplot(index2, aes(x=get(input$x.axis2), y=get(input$y.axis2),
colour = get(input$group_complex_dot),
fill = get(input$group_complex_dot),
shape = get(input$group_complex_dot),
size = get(input$group_complex_dot),
))+
geom_point() +
scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
limits = c(input$min.x,10^input$max.x),
labels = trans_format("log10", math_format(10^.x))) +
scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x),
limits = c(input$min.y,10^input$max.y),
labels = trans_format("log10", math_format(10^.x))) +
theme_bw() +
scale_color_manual(values=palette.complex) +
scale_shape_manual(values=shape.ggplot)+
scale_size_manual(values=size.ggplot)+
scale_fill_manual(values=palette.complex) +
geom_hline(yintercept = input$yintercept,colour=input$intercept.col,linetype=input$int.type)+
geom_vline(xintercept = input$xintercept,colour=input$intercept.col, linetype=input$int.type)+
annotation_logticks()  +
theme(text=element_text(size=20,family=input$font_type2),
plot.margin = margin(20, 20, 20, 20),
axis.text.x = element_text(colour="black",size=input$axis.numeric.size,angle=0,hjust=.5,vjust=.5,face="plain",family=input$font_type2),
axis.text.y = element_text(colour="black",size=input$axis.numeric.size,angle=0,hjust=1,vjust=0,face="plain",family=input$font_type2),
axis.title.x=element_text(colour="black",size=input$axis.title.size,angle=0,hjust=.5,vjust=.5,face="plain",family=input$font_type2),
axis.title.y = element_text(colour="black",size=input$axis.title.size,angle=90,hjust=.5,vjust=.5,face="plain",family=input$font_type2),
legend.title  =element_blank(),
legend.position = input$legend.dot,
legend.text = element_text(colour="black",size=input$legend.size.cd,hjust=.5,vjust=.5,face="plain",family=input$font_type2)) +
scale_alpha(guide = 'none') +
guides(size=FALSE, col = guide_legend(ncol=input$legend.column,override.aes = list(size=input$leg.dot.size)))+
labs(x=x_lable1,
y=y_lable1)
vals15$complex_dot
})
dot_plot.complex_UMAP <- reactive({
set.seed(123)
index <- input.data_CSV2();
validate(
need(nrow(index)>0,
"Upload file")
)
names(index) <- gsub("\\.", " ", names(index))
index <- as.data.frame(index)
y_lable1 <- bquote(.(input$y.axis2))
x_lable1 <-  bquote(.(input$x.axis2))
index[is.na(index)] <- "not_clonal"
selected.col <- index[names(index) %in% input$group_complex_dot]
names(selected.col) <- "V1"
index[names(index) %in% input$group_complex_dot] <- factor(selected.col$V1, levels = unique(selected.col$V1),labels = unique(selected.col$V1))
palette.complex <- unlist(colors.FACS.index())
shape.ggplot <- unlist(shape.FACS.index2())
size.ggplot <- unlist(size.FACS.index2())
names_unique <- as.data.frame(unique(selected.col))
names_unique_size <- cbind(names_unique,as.data.frame(size.ggplot))
names(names_unique_size)[1] <- input$group_complex_dot
index2 <- merge(index,names_unique_size,by=input$group_complex_dot)
vals15$complex_dot <- ggplot(index2, aes(x=get(input$x.axis2), y=get(input$y.axis2),
colour = get(input$group_complex_dot),
fill = get(input$group_complex_dot),
shape = get(input$group_complex_dot),
size = get(input$group_complex_dot),
))+
geom_point() +
theme_bw() +
scale_color_manual(values=palette.complex) +
scale_shape_manual(values=shape.ggplot)+
scale_size_manual(values=size.ggplot)+
scale_fill_manual(values=palette.complex) +
theme(text=element_text(size=20,family=input$font_type2),
plot.margin = margin(20, 20, 20, 20),
axis.text.x = element_text(colour="black",size=input$axis.numeric.size,angle=0,hjust=.5,vjust=.5,face="plain",family=input$font_type2),
axis.text.y = element_text(colour="black",size=input$axis.numeric.size,angle=0,hjust=1,vjust=0,face="plain",family=input$font_type2),
axis.title.x=element_text(colour="black",size=input$axis.title.size,angle=0,hjust=.5,vjust=.5,face="plain",family=input$font_type2),
axis.title.y = element_text(colour="black",size=input$axis.title.size,angle=90,hjust=.5,vjust=.5,face="plain",family=input$font_type2),
legend.title  =element_blank(),
legend.position = input$legend.dot,
legend.text = element_text(colour="black",size=input$legend.size.cd,hjust=.5,vjust=.5,face="plain",family=input$font_type2)) +
scale_alpha(guide = 'none') +
guides(size=FALSE, col = guide_legend(ncol=input$legend.column,override.aes = list(size=input$leg.dot.size)))+
labs(x=x_lable1,
y=y_lable1)
vals15$complex_dot
})
output$Add_size <- DT::renderDataTable( {
set.seed(123)
index <- input.data_CSV2();
validate(
need(nrow(index)>0,
"Upload file")
)
names(index) <- gsub("\\.", " ", names(index))
index <- as.data.frame(index)
y_lable1 <- bquote(.(input$y.axis2))
x_lable1 <-  bquote(.(input$x.axis2))
index[is.na(index)] <- "not_clonal"
selected.col <- index[names(index) %in% input$group_complex_dot]
names(selected.col) <- "V1"
index[names(index) %in% input$group_complex_dot] <- factor(selected.col$V1, levels = unique(selected.col$V1),labels = unique(selected.col$V1))
palette.complex <- unlist(colors.FACS.index())
shape.ggplot <- unlist(shape.FACS.index2())
size.ggplot <- unlist(size.FACS.index2())
names_unique <- as.data.frame(unique(selected.col))
names_unique_size <- cbind(names_unique,as.data.frame(size.ggplot))
names(names_unique_size)[1] <- input$group_complex_dot
index2 <- merge(index,names_unique_size,by=input$group_complex_dot)
# rownames(size.ggplot) <- unique(selected.col$V1)
datatable(as.data.frame(index2), extensions = "Buttons", options = list(searching = TRUE,
ordering = TRUE,
buttons = c('copy','csv', 'excel'),
dom = 'Bfrtip',
pageLength=2,
lengthMenu=c(2,5,10,20,50,100),
scrollX = TRUE
))
}, server = FALSE)
dot_plot.complex1 <- function () {
if(input$plot_type_umap == "overlaid dot plot") {
if (input$density_dotplot =="no" & input$grid.lines.dot =='no') {
if (input$Add_ellipse =="no") {
dot_plot.complex() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
}
else {
dot_plot.complex() +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
stat_ellipse(geom="polygon",level=0.8,alpha=0.2,lwd = 0.8)
}
}
else if (input$density_dotplot =="no" & input$grid.lines.dot =='yes') {
if (input$Add_ellipse =="no") {
dot_plot.complex()
}
else {
dot_plot.complex() +
stat_ellipse(geom="polygon",level=0.8,alpha=0.2,lwd = 0.8)
}
}
else if (input$density_dotplot =="yes" & input$grid.lines.dot =='no') {
if (input$Add_ellipse =="no") {
dot_plot <- dot_plot.complex() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
ggExtra::ggMarginal(dot_plot,groupColour = TRUE, groupFill = TRUE)
}
else {
dot_plot <- dot_plot.complex() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + stat_ellipse(geom="polygon",level=0.8,alpha=0.2,lwd = 0.8)
ggExtra::ggMarginal(dot_plot,groupColour = TRUE, groupFill = TRUE)
}
}
else {
if (input$Add_ellipse =="no") {
ggExtra::ggMarginal(dot_plot.complex(),groupColour = TRUE, groupFill = TRUE)
}
else {
dot_plot <- dot_plot.complex() +
stat_ellipse(geom="polygon",level=0.8,alpha=0.2,lwd = 0.8)
ggExtra::ggMarginal(dot_plot,groupColour = TRUE, groupFill = TRUE)
}
}
}
else if (input$plot_type_umap == "Ridge plot") {
dot_plot_ridge_df()
}
else{
if (input$Add_ellipse =="no" & input$grid.lines.dot =='no') {
dot_plot.complex_UMAP() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())
}
else if (input$Add_ellipse =="no" & input$grid.lines.dot =='yes') {
dot_plot.complex_UMAP()
}
else if (input$Add_ellipse =="yes" & input$grid.lines.dot =='no') {
dot_plot.complex_UMAP() +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
stat_ellipse(geom="polygon",level=0.8,alpha=0.2,lwd = 0.8)
}
else {
dot_plot.complex_UMAP() +
stat_ellipse(geom="polygon",level=0.8,alpha=0.2,lwd = 0.8)
}
}
}
output$dot_plot.complex2 <- renderPlot({
withProgress(message = 'Figure is being generated...',
detail = '', value = 0, {
test_fun()
})
dot_plot.complex1()
})
dot_plot_ridge_df  <- reactive({
set.seed(123)
index <- input.data_CSV2();
validate(
need(nrow(index)>0,
"Upload file")
)
names(index) <- gsub("\\.", " ", names(index))
title_axis <- bquote(.(input$x.axis2))
index <- as.data.frame(index)
index[is.na(index)] <- "not_clonal"
selected.col <- index[names(index) %in% input$group_complex_dot]
names(selected.col) <- "V1"
index[names(index) %in% input$group_complex_dot] <- factor(selected.col$V1, levels = unique(selected.col$V1),labels = unique(selected.col$V1))
palette.complex <- unlist(colors.FACS.index())
index$selected <- index[,names(index) %in% input$x.axis2]
index_clone <- index[,names(index) %in% c("cloneCount",input$group_complex_dot)]
index_clone <- index_clone %>%
select(cloneCount, everything())
df3 <- as.data.frame(ddply(index_clone,names(index_clone[-c(1)]),numcolwise(sum)))
names(df3)[2] <- "Sum_count"
df4 <- merge(index,df3,by=input$group_complex_dot)
index2 <- subset(df4,df4$Sum_count>2)
num <- unique(index[names(index) %in% input$group_complex_dot])
num$palette.complex <- palette.complex
df <- as.data.frame(unique(index2[,names(index2) %in% c("cloneCount",input$group_complex_dot)]))
# names(df) <- input$group_complex_dot
df.col1 <- merge(df,num,by=input$group_complex_dot)
x_lable1 <- bquote(Log[10]~(.(input$x.axis2)))
x_lable1
ggplot(index, aes(x = log10(selected), y = as.character(get(input$group_complex_dot)), fill = as.character(get(input$group_complex_dot)))) +
geom_density_ridges() +
theme_ridges() +
scale_fill_manual(values=df.col1$palette.complex)+
theme(legend.position = "none") +
labs(x=x_lable1) +
theme(text=element_text(size=20,family=input$font_type2),
plot.margin = margin(20, 20, 20, 20),
axis.text.x = element_text(colour="black",size=input$axis.numeric.size,angle=0,hjust=.5,vjust=.5,face="plain",family=input$font_type2),
axis.text.y = element_text(colour="black",size=input$axis.numeric.size,angle=0,hjust=1,vjust=0,face="plain",family=input$font_type2),
axis.title.x = element_text(colour="black",size=input$axis.title.size,angle=0,hjust=.5,vjust=.5,face="plain",family=input$font_type2),
axis.title.y = element_blank(),
# panel.grid.major.x = element_blank() ,
)
# legend.title  =element_blank(),
})
output$dot_plot_ridge_tab <- DT::renderDataTable( {
index <- input.data_CSV2();
validate(
need(nrow(index)>0,
"Upload file")
)
names(index) <- gsub("\\.", " ", names(index))
index <- as.data.frame(index)
index[is.na(index)] <- "not_clonal"
index$selected <- log10(index[,names(index) %in% input$x.axis2])
tab <-as.data.frame(TukeyHSD( aov(selected ~ as.character(get(input$group_complex_dot)),data = index))[1])
names(tab) <- c("diff" ,"lwr","upr","p.adj")
tab$stat <- ifelse(tab$p.adj<0.0001,"****",
ifelse(tab$p.adj<0.001,"***",
ifelse(tab$p.adj<0.01,"**",
ifelse(tab$p.adj<0.05,"*","NS"
))))
datatable(tab, extensions = "Buttons", options = list(searching = TRUE,
ordering = TRUE,
buttons = c('copy','csv', 'excel'),
dom = 'Bfrtip',
pageLength=10,
lengthMenu=c(2,5,10,20,50,100),
scrollX = TRUE
))
}, server = FALSE)
output$dot_plot_ridge <- renderPlot({
withProgress(message = 'Figure is being generated...',
detail = '', value = 0, {
test_fun()
})
dot_plot_ridge_df()
})
output$downloadPlot_complex.dotplot <- downloadHandler(
filename = function() {
x <- gsub(":", ".", Sys.time())
paste(input$name.colour3,"complex.dotplot_",gsub("/", "-", x), ".pdf", sep = "")
}, content = function(file) {
pdf(file, width=input$width_complex.dotplot,height=input$height_complex.dotplot, onefile = FALSE) # open the pdf device
print(dot_plot.complex1())
dev.off()},
contentType = "application/pdf" )
output$downloadPlotPNG_complex.dotplot <- downloadHandler(
filename = function() {
x <- gsub(":", ".", Sys.time())
paste(input$name.colour3,"complex.dotplot_", gsub("/", "-", x), ".png", sep = "")
},
content = function(file) {
png(file, width = input$width_png_complex.dotplot, height = input$height_png_complex.dotplot, res = input$resolution_PNG_complex.dotplot)
print(dot_plot.complex1())
dev.off()}, contentType = "application/png" # MIME type of the image
)
# upset diagram -----
vals23 <- reactiveValues(upset.plot=NULL)
observe({
updateSelectInput(
session,
"upset.select",
choices=names(input.data2()),
selected = "AVJ_aCDR3_BVJ_bCDR3")
})
observe({
updateSelectInput(
session,
"upset.group.select",
choices=names(select_group()),
selected = "group")
})
observe({
updateSelectInput(
session,
"order.of.group",
choices=select_group(),
selected = c("CD8","IFN"))
})
upset.parameters <- function () {
df <- input.data2();
validate(
need(nrow(df)>0,
error_message_val1)
)
df <- as.data.frame(df)
head(df)
unique.df <- unique(df[c(input$upset.select,input$upset.group.select)])
names(unique.df) <- c("chain","group")
unique.df$cloneCount <- 1
mat <- acast(unique.df, chain~group, value.var="cloneCount")
mat[is.na(mat)] <- 0
mat <- as.data.frame(mat)
# a <- as.data.frame(unique(names(mat)))
#   a$V1 <- distinctColorPalette(dim(a)[1])
df.x <- make_comb_mat(mat)
if (input$upset_anno == "Colour by degree") {
your_list <- c(input$upset_colours_list1)
your_list_df <- as.data.frame((unlist(strsplit(your_list, ','))))
names(your_list_df) <- "ID"
ht = draw(UpSet(df.x,
pt_size = unit(input$upset.point.size, "mm"),
lwd = input$upset.lwd,
row_names_gp =  gpar(fontfamily = input$font_type,fontsize = input$upset.text.size),#changes font size of "set size" labels
column_names_gp = gpar(fontfamily = input$font_type),
comb_col = c(your_list_df$ID)[comb_degree(df.x)],
top_annotation = upset_top_annotation(df.x,
numbers_gp = gpar(fontfamily = input$font_type,fontsize = input$font.size.anno.upset),
annotation_name_gp = gpar(fontfamily = input$font_type,fontsize=input$font.size.anno.upset),
gp = gpar(fill = input$top_annotation_colour),
),
right_annotation = upset_right_annotation(df.x,
add_numbers = T,
numbers_gp = gpar(fontfamily = input$font_type,fontsize = input$font.size.anno.upset),
annotation_name_gp = gpar(fontfamily = input$font_type,fontsize=input$font.size.anno.upset),
gp = gpar(fill = input$right_annotation_colour),
),
set_order  = c(input$order.of.group)
), padding = unit(c(20, 20, 20, 20), "mm"))
}
else {
ht = draw(UpSet(df.x,
pt_size = unit(input$upset.point.size, "mm"),
lwd = input$upset.lwd,
row_names_gp =  gpar(fontfamily = input$font_type, fontsize = input$upset.text.size),
column_names_gp = gpar(fontfamily = input$font_type),
top_annotation = upset_top_annotation(df.x,
annotation_name_gp = gpar(fontfamily = input$font_type),
gp = gpar(fill = input$top_annotation_colour),
),
right_annotation = upset_right_annotation(df.x,
add_numbers = T,
numbers_gp = gpar(fontfamily = input$font_type,fontsize = input$font.size.anno.upset),
annotation_name_gp = gpar(fontfamily = input$font_type,fontsize=input$font.size.anno.upset),
gp = gpar(fill = input$right_annotation_colour),
),
set_order  = c(input$order.of.group)
), padding = unit(c(20, 20, 20, 20), "mm"))
}
od = column_order(ht)
cs = comb_size(df.x)
decorate_annotation("intersection_size", {
grid.text(cs[od], x = seq_along(cs), y = unit(cs[od], "native") + unit(2, "pt"),
default.units = "native", just = "bottom", gp = gpar(fontsize = input$upset.font.size, fontfamily = input$font_type)
) })
}
output$UpSet.plot <- renderPlot({
withProgress(message = 'Figure is being generated...',
detail = '', value = 0, {
test_fun()
})
upset.parameters()
})
upset.datatable1 <- reactive({
df <- input.data2();
validate(
need(nrow(df)>0,
error_message_val1)
)
df <- as.data.frame(df)
head(df)
unique.df <- unique(df[c(input$upset.select,input$upset.group.select)])
names(unique.df) <- c("chain","group")
unique.df$cloneCount <- 1
mat <- acast(unique.df, chain~group, value.var="cloneCount")
mat[is.na(mat)] <- 0
mat <- as.data.frame(mat)
mat
})
output$upset.datatable <- DT::renderDataTable( {
datatable(upset.datatable1(), extensions = "Buttons", options = list(searching = TRUE,
ordering = TRUE,
buttons = c('copy','csv', 'excel'),
dom = 'Bfrtip',
pageLength=2,
lengthMenu=c(2,5,10,20,50,100),
scrollX = TRUE
))
}, server = FALSE)
output$downloadPlot_upset <- downloadHandler(
filename = function() {
x <- gsub(":", ".", Sys.time())
paste("upset_",gsub("/", "-", x), ".pdf", sep = "")
}, content = function(file) {
pdf(file, width=input$width_upset,height=input$height_upset, onefile = FALSE) # open the pdf device
print(upset.parameters())
dev.off()}, contentType = "application/pdf" )
output$downloadPlotPNG_upset <- downloadHandler(
filename = function() {
x <- gsub(":", ".", Sys.time())
paste("upset_", gsub("/", "-", x), ".png", sep = "")
},
content = function(file) {
png(file, width = input$width_png_upset, height = input$height_png_upset, res = input$resolution_PNG_upset)
print(upset.parameters())
dev.off()}, contentType = "application/png" # MIME type of the image
)
}
shinyApp(ui, server)
}
runApp_TCR_EXPLORE_V1()
devtools::document()
runApp('R')
devtools::document()
devtools::check()
require('usethis')
use_cc0_license()
devtools::document()
devtools::document()
devtools::check()
devtools::build()
TCR.Explore::runApp_TCR_EXPLORE_V1()
# hetsangerseq <- readsangerseq("test-data/QC/SJS.TEN/E10630/Micromon/IFNg/IFNA-A10_C07.ab1")
hetsangerseq <- readsangerseq(system.file("extdata","test-data/QC/SJS.TEN/E10630/Micromon/IFNg/IFNA-A10_C07.ab1",package ="TCR.Explore"))
dataframe = read_xls(system.file("extdata","test-data/QC/Vquest_data/CD8_E10630_A.xls",package ="TCR.Explore"), sheet = 2)
dataframe = read_xls(system.file("extdata","test-data/QC/Vquest_data/CD8_E10630_A.xls",package ="TCR.Explore"), sheet = 1)
dataframe = read.csv(system.file("extdata","test-data/QC/QC.ab1_files/E0630.ab1_QC_2022-12-30.csv",package ="TCR.Explore"), header = T)
View(dataframe)
dataframe = read.csv(system.file("extdata","test-data/QC/QC.csv_files/SJS.TEN.three.samps.csv",package ="TCR.Explore"), header = T)
dataframe = read.table(system.file("extdata","test-data/QC/ImmunoSEQ/ES8_TSNLQEQIGW_3.tsv",package ="TCR.Explore"),header=T)
system.file("extdata","test-data/QC/ImmunoSEQ/ES8_TSNLQEQIGW_3.tsv",package ="TCR.Explore")
read.table(system.file("extdata","test-data/QC/ImmunoSEQ/ES8_TSNLQEQIGW_3.tsv",package ="TCR.Explore"))
read.table(system.file("extdata","test-data/QC/ImmunoSEQ/ES8_TSNLQEQIGW_3.tsv",package ="TCR.Explore"),sep="\t")
dataframe = read.table(system.file("extdata","test-data/QC/ImmunoSEQ/ES8_TSNLQEQIGW_3.tsv",package ="TCR.Explore"),sep="\t",header=T)
# dataframe = read.csv("test-data/Group/paired_unsummarised2021.09.22.csv",header=T)
dataframe = read.csv(system.file("extdata","test-data/Group/paired_TCR_file2022.05.24.csv",package ="TCR.Explore"))
# dataframe = read.csv("test-data/Group/paired_unsummarised2021.09.22.csv",header=T)
dataframe = read.csv(system.file("extdata","test-data/Group/ImmunoSEQ.test.csv",package ="TCR.Explore"),header= T)
dataframe = read.FCS(system.file("extdata","test-data/Index/Murine Lymph Node_INX_780 Fib index 2_001_018.fcs",package ="TCR.Explore"))
dataframe = read.csv(system.file("extdata","test-data/Index/DR4-780 TCR sequence data.csv",package ="TCR.Explore"),header = T)
dataframe = read.csv(system.file("extdata","test-data/Index/TCR_Explore_index.clonal.2021.11.19.csv",package ="TCR.Explore"),header = T)
devtools::document()
devtools::build()
TCR.Explore::runApp_TCR_EXPLORE_V1()
TCR.Explore::runApp_TCR_EXPLORE_V1()
